Datagram Congestion Control Protocol (DCCP) is an unreliable, connection
oriented protocol designed to solve issues present in UDP and TCP, particularly
for real-time and multimedia (streaming) traffic.
It divides into a base protocol and pluggable congestion control
modules called CCIDs. Like pluggable TCP congestion control, at least one CCID
needs to be enabled in order for the protocol to function properly. In the Linux
implementation, this is the TCP-like CCID2. Additional CCIDs, such as
the TCP-friendly CCID3, are optional.

In recent months I have researched and reviewed various parts of the Linux kernel networking section, In this time i came across a use-after-free vulnerability in the DCCP component in the latest Linux kernel release(5.8.10).

To trigger the use-after-free we need to follow and understand how the uaf happens behind the scenes:

We create a socket with type ```SOCK_DCCP``` and protocol ```IPPROTO_IP```:
```c
socket(AF_INET6,SOCK_DCCP,IPPROTO_IP);
```
and put the socket on ```listen()```, the socket object is in DCCP_LISTEN state, behind the scene we are processing LISTEN state via ```dccp_create_openreq_child()```:

```c
struct sock *dccp_create_openreq_child(struct sock *sk,
				       const struct request_sock *req,
				       const struct sk_buff *skb)
{
	struct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC);
	if (newsk != NULL) {
		struct dccp_request_sock *dreq = dccp_rsk(req);
		struct inet_connection_sock *newicsk = inet_csk(newsk);
		struct dccp_sock *newdp = dccp_sk(newsk);
		newdp->dccps_role	    = DCCP_ROLE_SERVER;
		newdp->dccps_hc_rx_ackvec   = NULL;
		newdp->dccps_service_list   = NULL;
    ...
}
```
We can see in ```dccp_create_openreq_child``` that we are cloning our socket object.
The problem is the pointers to dccps_hc_rx_ccid and
dccps_hc_tx_ccid are copied. When CCID features are activated on the child
socket, the CCID objects are freed, leaving the parent socket with dangling
pointers.

If one of the socket objects is disconnected/closes, then it
it frees dccps_hc_rx_ccid/dccps_hc_tx_ccid and provides us a dangling pointer in the other socket object.

to make one of our socket object to disconnect we call connect with AF_UNSPEC and it will "free" our socket via dccp_disconnect.
```dccp_disconnect()``` sets the socket state to DCCP_CLOSED, and forgets to free and assign NULL to
dccps_hc_rx_ccid and dccps_hc_tx_ccid.

then, we need to call ```connect()``` with a new socket with the same type and protocol as the first one.
after that we have to call ```listen()``` with our new socket so our new socket object will get cloned with ```dccp_create_openreq_child()```.
```dccp_create_openreq_child()``` will return a new socket object thats holds the dangling pointers of dccps_hc_rx_ccid/dccps_hc_tx_ccid
which leads to that the old socket and the new socket hold the same memory of dccps_hc_rx_ccid/dccps_hc_tx_ccid.
 
if we want get arbitrary call with our dangling pointer (the freed object that we are using after we free ;D ), we have to dereference the dangling pointer 
with close/getsockopt.

```ccid_hc_tx_delete``` is the function that responsible to free dccps_hc_rx_ccid/dccps_hc_tx_ccid:

```c
void ccid_hc_tx_delete(struct ccid *ccid, struct sock *sk)
{
	if (ccid != NULL) {
		if (ccid->ccid_ops->ccid_hc_tx_exit != NULL)
			ccid->ccid_ops->ccid_hc_tx_exit(sk);      
		kmem_cache_free(ccid->ccid_ops->ccid_hc_tx_slab, ccid);
	}
}
```
 
we can see that this line: ```ccid->ccid_ops->ccid_hc_tx_exit(sk);``` is calling a function pointer.
if we call this function again we have arbitrary call from a freed object.

in order to exploit this and get IP control, we have to spray the heap of the kernel.



